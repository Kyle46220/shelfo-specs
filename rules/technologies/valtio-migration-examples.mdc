---
description: 
globs: 
alwaysApply: false
---
---
description: Migration guide and examples for transitioning from Zustand to Valtio state management
globs: **/configurator/store/**/*.*, **/configurator/hooks/**/*.*
alwaysApply: false
---

# Zustand to Valtio Migration Patterns

This guide provides patterns and examples for migrating from Zustand's immutable state model to Valtio's mutable proxy-based approach.

## Core Conceptual Differences

| Zustand | Valtio |
|---------|--------|
| Immutable state model | Mutable state model |
| `setState` for updates | Direct mutations |
| Selectors for optimization | Automatic tracking with `useSnapshot` |
| Custom store hooks | Proxy objects |
| Functional setState approach | Direct property access and mutation |

## Store Creation

### Zustand Store
```typescript
// Zustand store
import { create } from 'zustand'

type ConfigState = {
  dimensions: { width: number, height: number, depth: number },
  material: string,
  color: string,
  // Actions
  setDimensions: (width?: number, height?: number, depth?: number) => void,
  setMaterial: (material: string) => void,
  setColor: (color: string) => void
}

export const useConfigStore = create<ConfigState>((set) => ({
  dimensions: { width: 100, height: 200, depth: 30 },
  material: 'oak',
  color: 'natural',
  
  // Actions
  setDimensions: (width, height, depth) => set((state) => ({ 
    dimensions: { 
      width: width ?? state.dimensions.width,
      height: height ?? state.dimensions.height,
      depth: depth ?? state.dimensions.depth
    }
  })),
  setMaterial: (material) => set({ material }),
  setColor: (color) => set({ color })
}))
```

### Valtio Store
```typescript
// Valtio store
import { proxy } from 'valtio'

type ConfigState = {
  dimensions: { width: number, height: number, depth: number },
  material: string,
  color: string
}

export const configStore = proxy<ConfigState>({
  dimensions: { width: 100, height: 200, depth: 30 },
  material: 'oak',
  color: 'natural'
})

// Actions as functions (optional pattern)
export const configActions = {
  setDimensions: (width?: number, height?: number, depth?: number) => {
    if (width !== undefined) configStore.dimensions.width = width
    if (height !== undefined) configStore.dimensions.height = height
    if (depth !== undefined) configStore.dimensions.depth = depth
  },
  setMaterial: (material: string) => {
    configStore.material = material
  },
  setColor: (color: string) => {
    configStore.color = color
  }
}

// Alternative: Actions as methods on the store
export const configStoreWithMethods = proxy<ConfigState & {
  setDimensions(width?: number, height?: number, depth?: number): void,
  setMaterial(material: string): void,
  setColor(color: string): void
}>({
  dimensions: { width: 100, height: 200, depth: 30 },
  material: 'oak',
  color: 'natural',
  
  setDimensions(width, height, depth) {
    if (width !== undefined) this.dimensions.width = width
    if (height !== undefined) this.dimensions.height = height
    if (depth !== undefined) this.dimensions.depth = depth
  },
  setMaterial(material) {
    this.material = material
  },
  setColor(color) {
    this.color = color
  }
})
```

## Component Integration

### Zustand Component
```tsx
// Zustand component integration
import React from 'react'
import { useConfigStore } from './store'

export const DimensionsPanel = () => {
  // Select only what you need
  const width = useConfigStore(state => state.dimensions.width)
  const height = useConfigStore(state => state.dimensions.height)
  const setDimensions = useConfigStore(state => state.setDimensions)
  
  return (
    <div>
      <div>
        Width: 
        <input 
          type="number" 
          value={width}
          onChange={(e) => setDimensions(parseInt(e.target.value), undefined, undefined)}
        />
      </div>
      <div>
        Height:
        <input 
          type="number" 
          value={height}
          onChange={(e) => setDimensions(undefined, parseInt(e.target.value), undefined)}
        />
      </div>
    </div>
  )
}
```

### Valtio Component
```tsx
// Valtio component integration
import React from 'react'
import { useSnapshot } from 'valtio'
import { configStore, configActions } from './store'

export const DimensionsPanel = () => {
  // Get snapshot for reading values
  const snap = useSnapshot(configStore)
  
  return (
    <div>
      <div>
        Width: 
        <input 
          type="number" 
          value={snap.dimensions.width}
          onChange={(e) => {
            // Direct mutation
            configStore.dimensions.width = parseInt(e.target.value)
            // OR using actions
            // configActions.setDimensions(parseInt(e.target.value))
          }}
        />
      </div>
      <div>
        Height:
        <input 
          type="number" 
          value={snap.dimensions.height}
          onChange={(e) => {
            // Direct mutation
            configStore.dimensions.height = parseInt(e.target.value)
            // OR using actions
            // configActions.setDimensions(undefined, parseInt(e.target.value))
          }}
        />
      </div>
    </div>
  )
}
```

## Selective State Subscriptions

### Zustand Selective Subscription
```tsx
// Zustand selective subscription
const WidthDisplay = () => {
  // Only subscribes to width changes
  const width = useConfigStore(state => state.dimensions.width)
  return <div>Width: {width}</div>
}
```

### Valtio Selective Subscription
```tsx
// Valtio selective subscription with object destructuring
const WidthDisplay = () => {
  // Only subscribes to dimensions, specifically width
  const { width } = useSnapshot(configStore.dimensions)
  return <div>Width: {width}</div>
}

// Alternative: using a selector function
const WidthDisplayWithSelector = () => {
  // Only subscribes to width changes using selector function
  const width = useSnapshot(configStore, { 
    sync: true 
  }).dimensions.width
  
  return <div>Width: {width}</div>
}
```

## Computed Values

### Zustand Computed Values
```typescript
// Zustand - computed values with selectors
const totalVolume = useConfigStore(state => {
  const { width, height, depth } = state.dimensions
  return width * height * depth
})

// In the store definition:
export const useConfigStore = create<ConfigState>((set, get) => ({
  dimensions: { width: 100, height: 200, depth: 30 },
  // ...
  
  // Computed method
  getVolume: () => {
    const { width, height, depth } = get().dimensions
    return width * height * depth
  }
}))
```

### Valtio Computed Values
```typescript
// Valtio - computed values with getters
export const configStore = proxy<ConfigState & {
  get volume(): number
}>({
  dimensions: { width: 100, height: 200, depth: 30 },
  material: 'oak',
  color: 'natural',
  
  // Computed property as getter
  get volume() {
    const { width, height, depth } = this.dimensions
    return width * height * depth
  }
})

// Usage in component
const VolumeDisplay = () => {
  const snap = useSnapshot(configStore)
  return <div>Volume: {snap.volume} cubic units</div>
}
```

## Middleware / Devtools

### Zustand Devtools
```typescript
// Zustand with devtools
import { create } from 'zustand'
import { devtools } from 'zustand/middleware'

export const useConfigStore = create<ConfigState>()(
  devtools(
    (set) => ({
      dimensions: { width: 100, height: 200, depth: 30 },
      // rest of the store
    }),
    { name: 'Config Store' }
  )
)
```

### Valtio Devtools
```typescript
// Valtio with devtools
import { proxy } from 'valtio'
import { devtools } from 'valtio/utils'

export const configStore = proxy({
  dimensions: { width: 100, height: 200, depth: 30 },
  // rest of the store
})

// Connect to Redux DevTools
if (process.env.NODE_ENV === 'development') {
  devtools(configStore, { name: 'Config Store' })
}
```

## Persisting State

### Zustand Persistence
```typescript
// Zustand with persist middleware
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

export const useConfigStore = create<ConfigState>()(
  persist(
    (set) => ({
      dimensions: { width: 100, height: 200, depth: 30 },
      // rest of the store
    }),
    { 
      name: 'config-storage', 
      storage: localStorage 
    }
  )
)
```

### Valtio Persistence
```typescript
// Valtio with manual persistence
import { proxy, subscribe } from 'valtio'
import { subscribeKey } from 'valtio/utils'

export const configStore = proxy({
  dimensions: { width: 100, height: 200, depth: 30 },
  // rest of the store
})

// Load from storage on init
const savedConfig = localStorage.getItem('config-storage')
if (savedConfig) {
  try {
    const parsed = JSON.parse(savedConfig)
    Object.assign(configStore, parsed)
  } catch (e) {
    console.error('Failed to parse saved config')
  }
}

// Save to storage on change
subscribe(configStore, () => {
  localStorage.setItem('config-storage', JSON.stringify(configStore))
})

// Alternative: Listen to specific properties
subscribeKey(configStore, 'dimensions', (dimensions) => {
  console.log('Dimensions changed:', dimensions)
  // Save just this piece to storage
})
```

## Advanced Patterns

### Zustand Async Actions
```typescript
// Zustand async actions
export const useConfigStore = create<ConfigState>((set) => ({
  dimensions: { width: 100, height: 200, depth: 30 },
  isLoading: false,
  error: null,
  
  // Async action
  loadPreset: async (presetId: string) => {
    set({ isLoading: true, error: null })
    try {
      const response = await fetch(`/api/presets/${presetId}`)
      const preset = await response.json()
      set({ 
        dimensions: preset.dimensions,
        material: preset.material,
        color: preset.color,
        isLoading: false
      })
    } catch (error) {
      set({ isLoading: false, error: String(error) })
    }
  }
}))
```

### Valtio Async Actions
```typescript
// Valtio async actions
export const configStore = proxy<ConfigState & {
  isLoading: boolean,
  error: string | null
}>({
  dimensions: { width: 100, height: 200, depth: 30 },
  material: 'oak',
  color: 'natural',
  isLoading: false,
  error: null
})

// Actions defined separately
export const configActions = {
  // Async action
  loadPreset: async (presetId: string) => {
    configStore.isLoading = true
    configStore.error = null
    try {
      const response = await fetch(`/api/presets/${presetId}`)
      const preset = await response.json()
      // Update multiple properties
      Object.assign(configStore, {
        dimensions: preset.dimensions,
        material: preset.material,
        color: preset.color,
        isLoading: false
      })
    } catch (error) {
      configStore.isLoading = false
      configStore.error = String(error)
    }
  }
}
```

## Common Migration Pitfalls

1. **Forgetting to use snapshots for reading**:
   ```jsx
   // WRONG: Reading directly from store
   return <div>{configStore.dimensions.width}</div>
   
   // CORRECT: Using snapshot for reading
   const snap = useSnapshot(configStore)
   return <div>{snap.dimensions.width}</div>
   ```

2. **Trying to mutate a snapshot**:
   ```jsx
   // WRONG: Mutating the snapshot
   const snap = useSnapshot(configStore)
   const handleClick = () => {
     snap.dimensions.width = 150 // This won't work!
   }
   
   // CORRECT: Mutate the store directly
   const handleClick = () => {
     configStore.dimensions.width = 150
   }
   ```

3. **Overcomplicating actions**:
   ```jsx
   // WRONG: Overly complex action pattern
   const updateWidth = (width) => {
     const newDimensions = { ...configStore.dimensions, width }
     Object.assign(configStore, { dimensions: newDimensions })
   }
   
   // CORRECT: Simple direct mutation
   const updateWidth = (width) => {
     configStore.dimensions.width = width
   }
   ```

4. **Not handling nested objects carefully during migration**:
   ```jsx
   // WRONG: Forgetting nested objects in migration
   const zustandStore = useConfigStore.getState()
   const valtioStore = proxy({
     dimensions: zustandStore.dimensions, // Shallow copy!
     material: zustandStore.material
   })
   
   // CORRECT: Proper deep copying during migration
   const zustandStore = useConfigStore.getState()
   const valtioStore = proxy({
     dimensions: { ...zustandStore.dimensions }, // Proper copy
     material: zustandStore.material
   })
   ```

## Migration Approach Recommendations

1. **Incremental Migration**: Create Valtio stores alongside existing Zustand stores initially, with bridge functions to keep them in sync during the transition period.

2. **Feature-Based Migration**: Migrate one feature at a time rather than attempting to migrate the entire state management system at once.

3. **Testing**: Write comprehensive tests before and after migration to ensure behavior doesn't change.

4. **Component Adaptation**: Update components one at a time, starting with leaf components that have the fewest dependencies.

5. **Dual Rendering**: During migration, support both access patterns temporarily to avoid breaking existing functionality.

## Tools to Help Migration

```typescript
// Helper function to create a Valtio store from Zustand
function createValtioFromZustand<T extends object>(useZustandStore: any): T {
  const initialState = useZustandStore.getState()
  // Create deep clone without functions
  const stateWithoutFunctions = JSON.parse(JSON.stringify(
    Object.fromEntries(
      Object.entries(initialState).filter(([_, v]) => typeof v !== 'function')
    )
  ))
  return proxy<T>(stateWithoutFunctions as T)
}
```


