# TypeScript Safety Guidelines

---
description: TypeScript coding standards and safety practices
globs: **/*.ts, **/*.tsx
alwaysApply: true
---

## Type Definitions

### Object Indexing
```typescript
// GOOD: Properly typed dynamic objects
interface DynamicObject {
  [key: string]: any;  // Base index signature
  knownProp: string;
}

// BAD: Missing index signature
interface BadObject {
  knownProp: string;
  // Will error when accessing dynamic properties
}
```

### Type Guards
```typescript
// GOOD: Type guard implementation
function isProductType(type: unknown): type is ProductType {
  return typeof type === 'string' && 
         Object.keys(productRegistry).includes(type);
}

// Usage
if (isProductType(someValue)) {
  // TypeScript knows someValue is ProductType here
}
```

### Error Type Safety
```typescript
// GOOD: Type-safe error handling
try {
  await riskyOperation();
} catch (error) {
  const errorMessage = error instanceof Error 
    ? error.message 
    : String(error);
}
```

## Best Practices

1. Always use strict mode:
```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true
  }
}
```

2. Define return types explicitly:
```typescript
// GOOD
function calculateTotal(items: Item[]): number {
  return items.reduce((sum, item) => sum + item.price, 0);
}

// BAD
function calculateTotal(items: Item[]) {
  return items.reduce((sum, item) => sum + item.price, 0);
}
```

3. Use discriminated unions for complex states:
```typescript
type State = 
  | { status: 'loading' }
  | { status: 'error'; error: Error }
  | { status: 'success'; data: Data };
```

## Testing Requirements

1. Type coverage tests:
```typescript
it('should maintain type safety', () => {
  // @ts-expect-error
  const badAccess = obj['nonexistent'];
  expect(badAccess).toBeUndefined();
});
``` 