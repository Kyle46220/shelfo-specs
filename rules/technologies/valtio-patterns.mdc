---
description: Guidelines for using Valtio state management in the configurator
globs: **/configurator/store/**/*.*, **/configurator/hooks/**/*.*
alwaysApply: true
---

# Valtio State Management Patterns

## Store Structure

- Create a proxy store with flat structure:
  ```jsx
  // GOOD: Flat store with logical grouping
  const store = proxy({
    // Core configuration
    dimensions: { width: 100, height: 200, depth: 30 },
    appearance: { color: "natural", material: "oak" },
    features: { legs: "timber", backPanel: true },
    
    // UI state (separate from core model)
    ui: { 
      activeTab: "dimensions",
      hoveredPart: null
    },
    
    // Computation functions
    compute: {
      getPosition: (dimension, scale) => (scale - 1) / 2 * dimension,
      getEdge: (dimension, scale) => dimension / 2 * scale - dimension / 2
    }
  });
  ```

## Store Access Pattern

- ALWAYS follow this pattern in components:
  ```jsx
  // GOOD: Consistent store access pattern
  function Component() {
    // 1. Get store reference
    const store = useConfiguration();
    // 2. Create single snapshot
    const snap = useSnapshot(store);
    // 3. Destructure from snapshot for reads
    const { config, ui } = snap;
    // 4. Keep actions from store
    const { actions } = store;
    
    // Use snap.X for reading
    return <div>{snap.dimensions.width}</div>;
    
    // Use actions.X for writing
    const handleClick = () => actions.updateDimensions(100, 200);
  }
  ```

- NEVER create snapshots of snapshots:
  ```jsx
  // BAD: Creating snapshot of already snapshotted value
  const snap = useSnapshot(store);
  const configSnapshot = useSnapshot(snap.config); // WRONG!
  
  // GOOD: Use single snapshot
  const snap = useSnapshot(store);
  const { config } = snap; // Access directly from snapshot
  ```

## Hook Implementation

- Keep hooks simple and focused:
  ```jsx
  // GOOD: Simple store access hook
  export function useConfiguration() {
    return configuratorStore;
  }
  
  // BAD: Complex hook with internal snapshots
  export function useConfiguration(section) {
    const snap = useSnapshot(store); // Don't create snapshots in hooks
    return snap[section]; // Don't return snapshot pieces
  }
  ```

## State Updates

- Use actions for all state mutations:
  ```jsx
  // GOOD: Actions pattern
  const store = proxy({
    state: { count: 0 },
    actions: {
      increment() {
        store.state.count += 1;
      },
      updateConfig(updates) {
        Object.assign(store.state, updates);
      }
    }
  });
  ```

## Reference Data

- Use `ref` for non-reactive data:
  ```jsx
  // GOOD: Using ref for static/reference data
  const store = proxy({
    // Reactive state
    config: { /* ... */ },
    
    // Non-reactive reference data
    uiOptions: ref(defaultOptions),
    presets: ref({}),
    constants: ref({
      MIN_WIDTH: 100,
      MAX_WIDTH: 300
    })
  });
  ```

## Performance Optimization

- Minimize snapshot creation:
  ```jsx
  // BAD: Multiple snapshots
  function Component() {
    const configSnap = useSnapshot(store.config);
    const uiSnap = useSnapshot(store.ui);
    
    return <div>{configSnap.width}</div>;
  }
  
  // GOOD: Single snapshot with destructuring
  function Component() {
    const snap = useSnapshot(store);
    const { config, ui } = snap;
    
    return <div>{config.width}</div>;
  }
  ```

## Common Pitfalls

1. Creating snapshots of snapshots
2. Accessing store directly for reads
3. Creating multiple snapshots in one component
4. Mutating state outside actions
5. Not using `ref` for static data

## Debugging

- Use Valtio devtools in development:
  ```jsx
  if (process.env.NODE_ENV === 'development') {
    devtools(store, { name: "Store Name" });
  }
  ```

## Testing

- Mock the store in tests:
  ```jsx
  // In test file
  import { expect, vi, describe, it } from 'vitest';
  import { configuratorStore } from './store';
  import { proxy } from 'valtio';
  
  // Mock the store module
  vi.mock('./store', () => ({
    configuratorStore: proxy({
      // Test data
      config: {
        dimensions: { width: 100, height: 200, depth: 30 }
      },
      ui: { activeTab: 'dimensions' },
      actions: {
        updateDimensions: vi.fn()
      }
    })
  }));
  
  describe('Component using store', () => {
    it('should render with initial state', () => {
      // Test implementation
    });
    
    it('should call store actions correctly', () => {
      // Verify action calls
      expect(configuratorStore.actions.updateDimensions).toHaveBeenCalledWith(100, 200, 30);
    });
  });
  ```

- Reset mocks between tests:
  ```jsx
  beforeEach(() => {
    vi.clearAllMocks();
  });
  ```

- Test async store updates:
  ```jsx
  it('should handle async updates', async () => {
    // Arrange
    const asyncAction = vi.fn().mockResolvedValue({ success: true });
    configuratorStore.actions.asyncUpdate = asyncAction;
    
    // Act
    await configuratorStore.actions.asyncUpdate();
    
    // Assert
    expect(asyncAction).toHaveBeenCalled();
  });
  ```

## Important Notes

- Always create snapshots at the component level
- Never create snapshots of snapshots
- Use a single snapshot per component
- Keep store structure flat
- Use `ref` for non-reactive data
- Follow the store access pattern consistently

## Store Structure
- Always initialize arrays and objects with `ref` to make them non-reactive
- Use `ref` for any data that doesn't need reactivity (e.g., reference data, presets)
- Initialize all state properties in the initial state object
- Ensure arrays are initialized as empty arrays, not undefined
- Ensure objects are initialized with their expected shape

## Actions
- Define all actions when creating the store, not after
- Use proper type annotations for all actions
- Handle errors gracefully in actions
- Use `ref` when updating arrays or objects in actions

## Using the Store
- Always use `useSnapshot` to read from the store
- Use optional chaining when accessing potentially undefined properties
- Add null checks for required properties
- Initialize configuration before accessing it

## Common Pitfalls
- "proxyState is not iterable" error: Make sure arrays are properly initialized with `ref`
- "Cannot read property of undefined": Add proper null checks and optional chaining
- Type errors: Ensure proper type annotations and handle undefined cases

## Best Practices
- Keep the store structure flat when possible
- Use computed values for derived state
- Document the store structure and actions
- Add TypeScript interfaces for the store and its actions
- Use constants for default values and configuration

## Example Store Structure
```typescript
import { proxy, ref } from 'valtio';

const initialState = {
  // Core state (reactive)
  count: 0,
  status: 'idle',
  
  // Reference data (non-reactive)
  options: ref([]),
  metadata: ref({}),
  
  // Nested state
  ui: {
    isLoading: false,
    error: null
  }
};

const store = proxy({
  ...initialState,
  actions: {
    increment() {
      store.count += 1;
    },
    setOptions(options) {
      store.options = ref(options || []);
    }
  }
});
```

## Example Usage
```typescript
function Component() {
  const snap = useSnapshot(store);
  
  // Use optional chaining and null checks
  const options = snap?.options || [];
  const status = snap?.status || 'idle';
  
  // Initialize if needed
  useEffect(() => {
    if (!snap.isInitialized) {
      store.actions.initialize();
    }
  }, [snap.isInitialized]);
  
  return (
    // Component JSX
  );
}
```
