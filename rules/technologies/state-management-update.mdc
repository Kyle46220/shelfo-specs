---
description: Guidelines for state management using Valtio in the configurator
globs: **/configurator/store/**/*.*,**/configurator/hooks/**/*.*
alwaysApply: false
---
# State Management Guidelines

For comprehensive documentation on state management architecture and implementation, 
refer to [State Management Section in Technical Documentation](mdc:../docs/technical.md#4-state-management).

## Approved State Management Solutions

The project uses the following state management approaches:

1. **Valtio** - Primary state management for the 3D Configurator
   - Use for all 3D-related state that requires high-performance updates
   - Recommended for components that update frequently based on user interaction
   - Preferred for complex state with computed values

2. **Local Component State** - For isolated UI components
   - Use React's useState and useReducer for component-specific state
   - Appropriate for form inputs, toggles, and other UI-specific state

## Valtio Best Practices

- Use proxy for store creation
- Access state with useSnapshot for read operations
- Mutate state directly for write operations
- Define computed values as part of the store
- Use subscribe for non-React updates

Example implementation:

```jsx
import { proxy, useSnapshot, subscribe } from 'valtio';

// Create store
const store = proxy({
  dimensions: { width: 100, height: 200 },
  get area() {
    return this.dimensions.width * this.dimensions.height;
  }
});

// In components (read)
function DimensionsDisplay() {
  const snap = useSnapshot(store);
  return <div>{snap.dimensions.width} Ã— {snap.dimensions.height}</div>;
}

// State updates (write)
function updateDimensions(width, height) {
  store.dimensions.width = width;
  store.dimensions.height = height;
}

// Subscribe to changes (side effects)
subscribe(store.dimensions, () => {
  console.log('Dimensions changed:', store.dimensions);
});
```

## Performance Considerations

- Keep state as flat as possible
- Minimize property access in render functions
- Use selective subscriptions to prevent unnecessary re-renders
- Batch related state changes

## Integration with Medusa

When integrating with Medusa:

- Define clear mapping functions between store state and Medusa data structures
- Create serialization helpers for API communication
- Keep Medusa integration logic separate from core state management
